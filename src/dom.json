{
  "Document.createDocumentFragment":                         { "prefix": [ "cdf", "dom.createDocumentFragment" ],      "body": [ "${1:document}.createDocumentFragment();$2" ],                                        "description": "Creates a new document fragment.\n" },
  "Document.createElement":                                  { "prefix": [ "cel", "dom.createElement" ],               "body": [ "${1:document}.createElement(${2:elem});" ],                                          "description": "Creates a new element with the given tag name.\n" },
  "Document.createTextNode":                                 { "prefix": [ "ctn", "dom.createTextNode" ],              "body": [ "${1:document}.createTextNode(${2:data});" ],                                         "description": "Creates a text node.\n" },
  "Document.getElementById":                                 { "prefix": [ "gi", "dom.getElementById" ],               "body": [ "${1:document}.getElementById('${2:id}');" ],                                         "description": "Finding HTML elements by id.\n" },
  "Document.getElementsByClassName":                         { "prefix": [ "gc", "dom.getElementsByClassName" ],       "body": [ "${1:document}.getElementsByClassName('${2:className}');" ],                          "description": "Finding HTML elements by class name.\n" },
  "Document.getElementsByTagName":                           { "prefix": [ "gt", "dom.getElementsByTagName" ],         "body": [ "${1:document}.getElementsByTagName('${2:tagName}');" ],                              "description": "Finding HTML elements by tag name.\n" },
  "Document.querySelector":                                  { "prefix": [ "qs", "dom.querySelector" ],                "body": [ "${1:document}.querySelector('${2:selector}');" ],                                    "description": "querySelector\n" },
  "Document.querySelectorAll":                               { "prefix": [ "qsa", "dom.querySelectorAll" ],            "body": [ "${1:document}.querySelectorAll('${2:selector}');" ],                                 "description": "querySelectorAll\n" },

  "Node.childNodes":                                         { "prefix": [ "cn", "dom.childNodes" ],                   "body": [ "const ${2:nodeList} = ${1:node}.childNodes;" ],                                      "description": "Returns a live NodeList containing all the children of this node. \n" },
  "Node.parentElement":                                      { "prefix": [ "pe", "dom.parentElement" ],                "body": [ "const ${2:parentElement} = ${1:node}.parentElement;" ],                              "description": "Returns an Element that is the parent of this node. If the node has no parent, or if that parent is not an Element, this property returns null. \n" },
  "Node.parentNode":                                         { "prefix": [ "pn", "dom.parentNode" ],                   "body": [ "const ${2:parentNode} = ${1:node}.parentNode;" ],                                    "description": "Returns a Node that is the parent of this node. \n" },
  "Node.firstChild":                                         { "prefix": [ "fc", "dom.firstChild" ],                   "body": [ "const ${2:childNode} = ${1:node}.firstChild;" ],                                     "description": "Returns a Node representing the first direct child node of the node, or null if the node has no child.\n" },
  "Node.lastChild":                                          { "prefix": [ "lc", "dom.lastChild" ],                    "body": [ "const ${2:childNode} = ${1:node}.lastChild;" ],                                      "description": "Returns a Node representing the last direct child node of the node, or null if the node has no child.\n" },
  "Node.previousSibling":                                    { "prefix": [ "ps", "dom.previousSibling" ],              "body": [ "const ${2:previousNode} = ${1:node}.previousSibling;" ],                             "description": "Returns a Node representing the previous node in the tree, or null if there isn't such node.\n" },
  "Node.nextSibling":                                        { "prefix": [ "ns", "dom.nextSibling" ],                  "body": [ "const ${2:nextNode} = ${1:node}.nextSibling;" ],                                     "description": "Returns a Node representing the next node in the tree, or null if there isn't such node.\n" },
  "Node.textContent":                                        { "prefix": [ "tc", "dom.textContent" ],                  "body": [ "${1:node}.textContent = '${2:content}';" ],                                          "description": "Returns / Sets the textual content of an element and all its descendants.\n" },

  "Node.insertBefore()":                                     { "prefix": [ "ib", "dom.insertBefore" ],                 "body": [ "${1:node}.insertBefore(${2:newNode}, ${3:referenceNode});" ],                        "description": "insertBefore\n" },
  "Node.appendChild()":                                      { "prefix": [ "ac", "dom.appendChild" ],                  "body": [ "${1:node}.appendChild(${2:element});" ],                                             "description": "Adds the specified childNode argument as the last child to the current node.\n" },
  "Node.cloneNode()":                                        { "prefix": [ "cn", "dom.cloneNode" ],                    "body": [ "const ${2:newClone} = ${1:node}.cloneNode(true);" ],                                 "description": "Clone a Node, and optionally, all of its contents.\n" },
  "Node.getRootNode()":                                      { "prefix": [ "dom.getRootNode" ],                        "body": [ "const ${2:root} = ${1:node}.getRootNode(true);" ],                                   "description": "The getRootNode() method of the Node interface returns the context object's root, which optionally includes the shadow root if it is available.\n" },
  "Node.compareDocumentPosition()":                          { "prefix": [ "cdp", "dom.compareDocumentPosition" ],     "body": [ "const ${3:compareMask} = ${1:node}.compareDocumentPosition(${2:otherNode});" ],      "description": "Compares the position of the current node against another node in any other document.\n" },
  "Node.contains()":                                         { "prefix": [ "con", "dom.contains" ],                    "body": [ "${1:node}.contains(${2:otherNode});" ],                                              "description": "Returns a Boolean value indicating whether or not a node is a descendant of the calling node.\n" },
  "Node.removeChild()":                                      { "prefix": [ "rmc", "dom.removeChild" ],                 "body": [ "${1:node}.removeChild(${2:child});" ],                                               "description": "removeChild\n" },
  "Node.replaceChild()":                                     { "prefix": [ "rpc", "dom.replaceChild" ],                "body": [ "${1:parentNode}.replaceChild(${2:newChild}, ${3:oldChild});" ],                      "description": "replaceChild\n" },
  "Node.hasChildNodes()":                                    { "prefix": [ "hcn", "dom.hasChildNodes" ],               "body": [ "${1:node}.hasChildNodes()" ],                                                        "description": "hasChildNodes\n" },

  "parentNode.firstElementChild":                            { "prefix": [ "fec", "dom.firstElementChild" ],           "body": [ "const ${2:element} = ${1:parentNode}.firstElementChild;" ],                          "description": "Returns the first node which is both a child of this ParentNode and is also an Element, or null if there is none.\n" },
  "parentNode.lastElementChild":                             { "prefix": [ "lec", "dom.lastElementChild" ],            "body": [ "const ${2:element} = ${1:parentNode}.lastElementChild;" ],                           "description": "Returns the last node which is both a child of this ParentNode and is an Element, or null if there is none.\n" },
  "parentNode.childElementCount":                            { "prefix": [ "cec", "dom.childElementCount" ],           "body": [ "const ${2:count} = ${1:parentNode}.childElementCount;" ],                            "description": "Returns the number of children of this ParentNode which are elements.\n" },
  "parentNode.children":                                     { "prefix": [ "children", "dom.children" ],               "body": [ "const ${2:children} = ${1:parentNode}.children;" ],                                  "description": "Returns a live HTMLCollection containing all of the Element objects that are children of this ParentNode.\n" },
  "parentNode.append()":                                     { "prefix": [ "append", "dom.append" ],                   "body": [ "${1:parentNode}.append(${2:Nodes/DOMStrings});" ],                                   "description": "Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. \n" },
  "parentNode.prepend()":                                    { "prefix": [ "prepend", "dom.prepend" ],                 "body": [ "${1:parentNode}.prepend(${2:Nodes/DOMStrings});" ],                                  "description": "Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. \n" },

  "ChildNode.after()":                                       { "prefix": [ "after", "dom.after" ],                     "body": [ "${1:childNode}.after(${2:Nodes/DOMStrings});" ],                                     "description": "Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just after this ChildNode. \n" },
  "ChildNode.before()":                                      { "prefix": [ "before", "dom.before" ],                   "body": [ "${1:childNode}.before(${2:Nodes/DOMStrings});" ],                                    "description": "Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent,just before this ChildNode. \n" },
  "ChildNode.remove()":                                      { "prefix": [ "remove", "dom.remove" ],                   "body": [ "${1:childNode}.remove();" ],                                                         "description": "Removes this ChildNode from the children list of its parent.\n" },
  "ChildNode.replaceWith()":                                 { "prefix":[ "rw", "dom.replaceWith" ],                   "body": [ "${1:childNode}.replaceWith(${2:Node/DOMString});" ],                                 "description": "Replaces this ChildNode in the children list of its parent with a set of Node or DOMString objects.\n" },

  "Element.previousElementSibling":                          { "prefix": ["pes", "dom.previousElementSibling" ],       "body": [ "const ${2:prevElement} = ${1:NonDocumentTypeChildNode}.previousElementSibling;" ],   "description": "Returns the Element immediately prior to this node in its parent's children list, or null if there is no Element in the list prior to this node.\n" },
  "Element.nextElementSibling":                              { "prefix": ["nes", "dom.nextElementSibling" ],           "body": [ "const ${2:nextElement} = ${1:NonDocumentTypeChildNode}.nextElementSibling;" ],       "description": "Returns the Element immediately following this node in its parent's children list, or null if there is no Element in the list following this node.\n" },
  "Element.closest()":                                       { "prefix": ["closest", "dom.closest" ],                  "body": [ "const ${1:closestElement} = ${2:targetElement}.closest('${3:selectorString}');" ],   "description": "Returns the Element which is the closest ancestor of the current element (or the current element itself) which matches the selectors given in parameter.\n" },

  "Element.insertAdjacentHTML('beforebegin', 'DOMString')":  { "prefix": ["before", "dom.before.html" ],               "body": [ "${1:element}.insertAdjacentHTML('beforebegin', ${2:'DOMString'});" ],                "description": "Before the element itself.\n" },
  "Element.insertAdjacentHTML('afterend', 'DOMString')":     { "prefix": ["after", "dom.after.html" ],                 "body": [ "${1:element}.insertAdjacentHTML('afterend', ${2:'DOMString'});" ],                   "description": "After the element itself.\n" },
  "Element.insertAdjacentHTML('afterbegin', 'DOMString')":   { "prefix": ["prepend", "dom.prepend.html" ],             "body": [ "${1:element}.insertAdjacentHTML('afterbegin', ${2:'DOMString'});" ],                 "description": "Just inside the element, before its first child.\n" },
  "Element.insertAdjacentHTML('beforeend', 'DOMString')":    { "prefix": ["append", "dom.append.html" ],               "body": [ "${1:element}.insertAdjacentHTML('beforeend', ${2:'DOMString'});" ],                  "description": "Just inside the element, after its last child.\n" },
  "Element.insertAdjacentElement('beforebegin', element)":   { "prefix": ["before", "dom.before.element" ],            "body": [ "${1:element}.insertAdjacentElement('beforebegin', ${2:element});" ],                 "description": "Before the element itself.\n" },
  "Element.insertAdjacentElement('afterend', element)":      { "prefix": ["after", "dom.after.element" ],              "body": [ "${1:element}.insertAdjacentElement('afterend', ${2:element});" ],                    "description": "After the element itself.\n" },
  "Element.insertAdjacentElement('afterbegin', element)":    { "prefix": ["prepend", "dom.prepend.element" ],          "body": [ "${1:element}.insertAdjacentElement('afterbegin', ${2:element});" ],                  "description": "Just inside the element, before its first child.\n" },
  "Element.insertAdjacentElement('beforeend', element)":     { "prefix": ["append", "dom.append.element" ],            "body": [ "${1:element}.insertAdjacentElement('beforeend', ${2:element});" ],                   "description": "Just inside the element, after its last child.\n" },
  "Element.insertAdjacentText('beforebegin', value)":        { "prefix": ["before", "dom.before.text" ],               "body": [ "${1:element}.insertAdjacentText('beforebegin', ${2:value});" ],                      "description": "Before the element itself.\n" },
  "Element.insertAdjacentText('afterend', value)":           { "prefix": ["after", "dom.after.text" ],                 "body": [ "${1:element}.insertAdjacentText('afterend', ${2:value});" ],                         "description": "After the element itself.\n" },
  "Element.insertAdjacentText('afterbegin', value)":         { "prefix": ["prepend", "dom.prepend.text" ],             "body": [ "${1:element}.insertAdjacentText('afterbegin', ${2:value});" ],                       "description": "Just inside the element, before its first child.\n" },
  "Element.insertAdjacentText('beforeend', value)":          { "prefix": ["append", "dom.append.text" ],               "body": [ "${1:element}.insertAdjacentText('beforeend', ${2:value});" ],                        "description": "Just inside the element, after its last child.\n" },

  "Element.getClientRects()":                                { "prefix": ["gcr", "dom.getClientRects" ],               "body": [ "const ${3:rectCollection} = ${1:element}.getClientRects();" ],                       "description": "The getClientRects() method of the Element interface returns a collection of DOMRect objects that indicate the bounding rectangles for each CSS border box in a client.\n" },
  "Element.getBoundingClientRect()":                         { "prefix": ["gbcr", "dom.getBoundingClientRect" ],       "body": [ "const ${3:domRect} = ${1:element}.getBoundingClientRect();" ],                       "description": "The `Element.getBoundingClientRect()` method returns the size of an element and its position relative to the viewport.\n" },

  "Element.setAttribute()":                                  { "prefix": ["sa", "dom.setAttribute" ],                  "body": [ "${1:element}.setAttribute('${2:attrName}', '${3:value}');" ],                        "description": "Sets the value of a named attribute of the current node.\n" },
  "Element.getAttribute()":                                  { "prefix": ["ga", "dom.getAttribute" ],                  "body": [ "const ${3:attribute} = ${1:element}.getAttribute('${2:attrName}');" ],               "description": "Retrieves the value of the named attribute from the current node and returns it as an Object.\n" },
  "Element.hasAttribute()":                                  { "prefix": ["ha", "dom.hasAttribute" ],                  "body": [ "${1:element}.hasAttribute('${2:attrName}')" ],                                       "description": "Returns a Boolean indicating if the element has the specified attribute or not.\n" },
  "Element.removeAttribute()":                               { "prefix": ["ra", "dom.removeAttribute" ],               "body": [ "${1:element}.removeAttribute('${2:attrName}');" ],                                   "description": "Removes the named attribute from the current node.\n" },
  "Element.toggleAttribute()":                               { "prefix": ["ta", "dom.toggleAttribute" ],               "body": [ "${1:element}.toggleAttribute('${2:attrName}');" ],                                   "description": "Toggles a boolean attribute, removing it if it is present and adding it if it is not present, on the specified element.\n" },

  "Element.matches()":                                       { "prefix": ["matches", "dom.matches" ],                  "body": [ "${1:element}.matches('${2:selectorString}')" ],                                      "description": "Returns a Boolean indicating whether or not the element would be selected by the specified selector string.\n" },
  "Element.innerHTML":                                       { "prefix": ["ih", "dom.innerHTML" ],                     "body": [ "${1:htmlElement}.innerHTML = ${2:'DOMString'};" ],                                   "description": "The innerHTML property sets or returns the HTML content (inner HTML) of an element.\n" },
  "Element.outerHTML":                                       { "prefix": ["oh", "dom.outerHTML" ],                     "body": [ "${1:htmlElement}.outerHTML = ${2:'DOMString'};" ],                                   "description": "The outerHTML property sets or returns the HTML element and all it's content, including the start tag, it's attributes, and the end tag.\n" },
  "HTMLElement.innerText":                                   { "prefix": ["it", "dom.innerText" ],                     "body": [ "${1:htmlElement}.innerText = ${2:'renderText'};" ],                                  "description": "The innerText property sets or returns the text content of the specified node, and all its descendants.\n" },

  "Element.classList.add()":                                 { "prefix": ["cla", "dom.classList.add" ],                "body": [ "${1:element}.classList.add('${2:className}');" ],                                    "description": "Element.classList.add\n" },
  "Element.classList.contains()":                            { "prefix": ["clc", "dom.classList.contains" ],           "body": [ "${1:element}.classList.contains('${2:className}');" ],                               "description": "Element.classList.contains\n" },
  "Element.classList.remove()":                              { "prefix": ["clr", "dom.classList.remove" ],             "body": [ "${1:element}.classList.remove('${2:className}');" ],                                 "description": "Element.classList.remove\n" },
  "Element.classList.toggle()":                              { "prefix": ["clt", "dom.classList.toggle" ],             "body": [ "${1:element}.classList.toggle('${2:className}');" ],                                 "description": "Element.classList.toggle\n" },

  "Element.scroll()":                                        { "prefix": ["scroll", "dom.scroll" ],                    "body": [ "${1:element}.scroll({top: ${2:top}, left: ${3:left}, behavior: 'smooth'});" ],       "description": "The scroll() method of the Element interface scrolls the element to a particular set of coordinates inside a given element.\n" },
  "Element.scrollBy()":                                      { "prefix": ["scrollBy", "dom.scrollBy" ],                "body": [ "${1:element}.scrollBy({top: ${2:top}, left: ${3:left}, behavior: 'smooth'});" ],     "description": "The scrollBy() method of the Element interface scrolls an element by the given amount.\n" },
  "Element.scrollTo()":                                      { "prefix": ["scrollTo", "dom.scrollTo" ],                "body": [ "${1:element}.scrollTo({top: ${2:top}, left: ${3:left}, behavior: 'smooth'});" ],     "description": "The scrollTo() method of the Element interface scrolls to a particular set of coordinates inside a given element.\n" },
  "Element.scrollIntoView()":                                { "prefix": ["scrollIntoView", "dom.scrollIntoView" ],    "body": [ "${1:element}.scrollIntoView({behavior: 'smooth'});" ],                               "description": "The Element interface's scrollIntoView() method scrolls the element's parent container such that the element on which scrollIntoView() is called is visible to the user\n" },
  "Element.clientWidth":                                     { "prefix": ["clientWidth", "dom.clientWidth" ],          "body": [ "${1:element}.clientWidth" ],                                                         "description": "The Element.clientWidth property is zero for inline elements and elements with no CSS; otherwise, it's the inner width of an element in pixels. It includes padding but excludes borders, margins, and vertical scrollbars (if present).\n" },
  "Element.clientHeight":                                    { "prefix": ["clientHeight", "dom.clientHeight" ],        "body": [ "${1:element}.clientHeight" ],                                                        "description": "The Element.clientHeight read-only property is zero for elements with no CSS or inline layout boxes; otherwise, it's the inner height of an element in pixels. It includes padding but excludes borders, margins, and horizontal scrollbars (if present).\n" },
  "Element.clientLeft":                                      { "prefix": ["clientLeft", "dom.clientLeft" ],            "body": [ "${1:element}.clientLeft" ],                                                          "description": "The width of the left border of an element in pixels. It includes the width of the vertical scrollbar if the text direction of the element is right–to–left and if there is an overflow causing a left vertical scrollbar to be rendered. clientLeft does not include the left margin or the left padding. clientLeft is read-only.\n" },
  "Element.clientTop":                                       { "prefix": ["clientTop", "dom.clientTop" ],              "body": [ "${1:element}.clientTop" ],                                                           "description": "The width of the top border of an element in pixels. It is a read-only, integer property of element.\n" },
  "Element.scrollWidth":                                     { "prefix": ["scrollWidth", "dom.scrollWidth" ],          "body": [ "${1:element}.scrollWidth" ],                                                         "description": "The Element.scrollWidth read-only property is a measurement of the width of an element's content, including content not visible on the screen due to overflow.\n" },
  "Element.scrollHeight":                                    { "prefix": ["scrollHeight", "dom.scrollHeight" ],        "body": [ "${1:element}.scrollHeight" ],                                                        "description": "The Element.scrollHeight read-only property is a measurement of the height of an element's content, including content not visible on the screen due to overflow.\n" },
  "Element.scrollLeft":                                      { "prefix": ["scrollLeft", "dom.scrollLeft" ],            "body": [ "${1:element}.scrollLeft" ],                                                          "description": "The Element.scrollLeft property gets or sets the number of pixels that an element's content is scrolled from its left edge.\n" },
  "Element.scrollTop":                                       { "prefix": ["scrollTop", "dom.scrollTop" ],              "body": [ "${1:element}.scrollTop" ],                                                           "description": "The Element.scrollTop property gets or sets the number of pixels that an element's content is scrolled vertically.\n" },

  "HTMLElement.offsetWidth":                                 { "prefix": ["offsetWidth", "dom.offsetWidth" ],          "body": [ "${1:HTMLElement}.offsetWidth" ],                                                     "description": "The HTMLElement.offsetWidth read-only property returns the layout width of an element as an integer.\n" },
  "HTMLElement.offsetHeight":                                { "prefix": ["offsetHeight", "dom.offsetHeight" ],        "body": [ "${1:HTMLElement}.offsetHeight" ],                                                    "description": "The HTMLElement.offsetHeight read-only property returns the height of an element, including vertical padding and borders, as an integer.\n" },
  "HTMLElement.offsetTop":                                   { "prefix": ["offsetTop", "dom.offsetTop" ],              "body": [ "${1:HTMLElement}.offsetTop" ],                                                       "description": "The HTMLElement.offsetTop read-only property returns the distance of the current element relative to the top of the offsetParent node.\n" },
  "HTMLElement.offsetLeft":                                  { "prefix": ["offsetLeft", "dom.offsetLeft" ],            "body": [ "${1:HTMLElement}.offsetLeft" ],                                                      "description": "The HTMLElement.offsetLeft read-only property returns the number of pixels that the upper left corner of the current element is offset to the left within the HTMLElement.offsetParent node.\n" },
  "HTMLElement.offsetParent":                                { "prefix": ["offsetParent", "dom.offsetParent" ],        "body": [ "${1:HTMLElement}.offsetParent" ],                                                    "description": "The HTMLElement.offsetParent read-only property returns a reference to the element which is the closest (nearest in the containment hierarchy) positioned ancestor element. If there is no positioned ancestor element, the nearest ancestor td, th, table will be returned, or the body if there are no ancestor table elements either.\n" }
}
